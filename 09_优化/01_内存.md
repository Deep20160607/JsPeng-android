## java内存分配机制:
静态分配、栈式分配、堆分配
- 静态存储区域(方法区)
主要存放静态数据、全局 static 数据和常量。这块内存在程序编 译时就已经分配好，并且在程序整个运行期间都存在。

- 栈区
当方法被执行时，方法体内的局部变量(其中包括基础数据类型、对象的引用)都 在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内 置于处理器的指令集中，效率很高，但是分配的内存容量有限。

- 堆区
又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象 的实例。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。

## GC机制
堆内存中对象无引用,则被回收,主要用“可达性分析法”   
***通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所有的引用链，当一个对象 到GC Roots没有任何引用链(即GC Roots到对象不可达)时，则证明此对象是不可用的。***

## 内存抖动、内存泄漏、内存溢出是什么?
- 内存抖动
在java中,每创建一个对象,就会申请一块内存,存储对象信息.当程序被占用的内存到达临界 ,GC就会出动,释放一部分不再被使用的内存.当频繁创建对象就会造成内存不断的被创建又不断的被回收,短时间内反复操作,就会产生内存抖动

- 内存泄漏
本改被回收的对象,因为被持有引用,得不到回收

- 内存溢出
内存空间不够导致oom

## 内存泄漏场景?
- 单例引起的内存泄漏

由于单例的静态特性导致它的生命周期和整个应用的生命周期一样长，如果有对象已经不再使用了，但又却被单例持有引用，那么就会导致这个对象就没办法被回收，从而导致内存泄漏。
```java
// 使用了单例模式
public class AppManagerXiangxue {
    private static AppManagerXiangxue instance;
    private Context context;
    private AppManagerXiangxue(Context context) {
        this.context = context;
    }
    public static AppManagerXiangxue getInstance(Context context) {
        if (instance != null) {
            instance = new AppManagerXiangxue(context);
        }
        return instance;
    }
}
```

- 非静态内部类创建静态实例引起的内存泄漏

非静态内部类会默认持有外部类的引用，如果我们在外部类中去创建这个内部类对象，当频繁打开 关闭Activity，会导致重复创建对象，造成资源的浪费，为了避免这个问题我们一般会把这个实例设置为 静态，这样虽然解决了重复创建实例，但是会引发出另一个问题，就是静态成员变量它的生命周期是和 应用的生命周期一样长的，然而这个静态成员变量又持有该Activity的引用，所以导致这个Activity销毁 的时候，对象也是无法被回收的。

- Handler引起的内存泄漏

- 资源对象未关闭引起的内存泄露


## 内存泄漏工具分析

用AndroidStudio自带的内存分析工具分析，点击Dump Java Heap:会在代码区 生成当前时间点的 .hprof格式文件，里面当前的每个对象 内存占用情况


leakcanary  =》原理需要了解一下!!!
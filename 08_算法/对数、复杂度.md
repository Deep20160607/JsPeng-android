### 01.什么是对数
- 如果a的x次方等于N（a>0，且a不等于1），那么数x叫做以a为底N的对数（logarithm），记作x=logaN。其中，a叫做对数的底数，N叫做真数。
- 人们逐渐把以10为底的常用对数及以无理数e为底的自然对数分别记作lgN和lnN。
- 一般地，函数y=logaX（a>0，且a≠1）叫做对数函数，也就是说以幂（真数）为自变量，指数为因变量，底数为常量的函数，叫对数函数。
-loga1，log以a为底1的对数为0（a为常数） 恒过点（1，0）。

### 02.大O复杂度表示法
***从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。***
- T(n)=O(f(n))  
T(n)表示代码的执行时间；n表示数据规模的大小；f(n)表示每行代码执行次数的总和。因为这是一个公式，所以用f(n)表示。公式中的O，表示代码的执行时间T(n)与f(n)表达式成正比。
- 当 n 很大时，公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示下面两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n*n)。

#### 2.1 先分析两个案例(可不看)
https://github.com/yangchong211/YCBlogs/blob/master/leetcode/00.%E5%AF%BC%E5%90%91/02.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E5%AF%BC%E8%AE%BA.md

### 03.时间复杂度
***表示算法的执行时间与数据规模之间的增长关系***

#### 3.1.加法法则计算时间复杂度
- 加法法则：总复杂度等于量级最大的那段代码的复杂度

#### 3.2.乘法法则计算时间复杂度
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

#### 3.2.多项式时间复杂度
- O(1)常数阶 
- O(logn)、O(nlogn) 对数阶
```java
i=1;
while (i <= n) {
    i = i * 2;
}
```
通过 2x（2的x次方）=n 求解 x , 所以x=log2n   
**实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。**

- O(m+n)、O(m*n)
```java
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }
 
  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }
 
  return sum_1 + sum_2;
}
```
 - 从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。
    - 针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。


### 04.空间复杂度
***算法的存储空间与数据规模之间的增长关系***
- 例子：
    ```
    void print(int n) {
      int i = 0;
      int[] a = new int[n];
      for (i; i <n; ++i) {
        a[i] = i * i;
      }
     
      for (i = n-1; i >= 0; --i) {
        print out a[i]
      }
    }
    ```
- 跟时间复杂度分析一样
    - 可以看到，第 2 行代码中，申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。
    - 第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。